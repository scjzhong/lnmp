问题
        我们都知道mysql的主从分离是在应对更多的请求对数据库的操作而实现的一种策略。
        场景：在一次批量操作线上数据的时候（读与写均有）
        伪代码如下
        for($i=0; $i <100; $i++){
              $res1 = select * from where condition1;（读库）  操作1
              if(empty($res1)){
                    insert condition1;（写库）
              }else{
                    update condition1;（写库）
              }
         }
          
          伪代码如上
          只有condition1不存在的时候才会写
          但由于数据库采用的主从分离的原因 读在读库，写在写库
          当以上伪代码
          insert condition1;
          执行这句时。 写在写库同步到从库假设需要 100个cpu时钟
          而代码继续循环按照我们的设想接下来就只会执行update操作了。但是实际上还是出现了 insert操作
          因为代码循环到下一次可能只需要50个cpu时钟
          所以就导致第二次查的时候没有查到第一次的更新到读库的condition1
          才会出现第二次insert操作。
          这就造成了很大的问题数据错误。生产环境甚至可能出现难以想向的损失
          
          如何解决这类问题。
          基于框架开发的话相对简单点。如果框架自动做到读和写的分离
                        只需要开启事务即可。 保证在一个库执行所有的读和写。          
          